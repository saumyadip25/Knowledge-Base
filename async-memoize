function memoizeAsync(fn) {
  const cache = new Map();
  const inProgress = new Map();

  return async function (...args) {
    const key = JSON.stringify(args);

    // Case 1: If already cached → return cached value immediately
    if (cache.has(key)) {
      return Promise.resolve(cache.get(key));
    }

    // Case 2: If in progress → return the same pending promise
    if (inProgress.has(key)) {
      return inProgress.get(key);
    }
    console.log("API Call");
    // Case 3: No cache, no in-progress → call the original async function
    const promise = fn(...args)
      .then((result) => {
        cache.set(key, result); // Save in cache
        inProgress.delete(key); // Remove from in-progress
        return result;
      })
      .catch((err) => {
        inProgress.delete(key); // Clean up if error
        throw err;
      });

    inProgress.set(key, promise); // Store in-progress promise
    return promise;
  };
}

// Fake API
async function fetchUser(userId) {
  // console.log("API call for", userId);
  return new Promise((resolve) =>
    setTimeout(() => resolve({ userId, name: "User " + userId }), 500)
  );
}

// Memoized version
const memoizedFetchUser = memoizeAsync(fetchUser);

Promise.all([
  memoizedFetchUser(1),
  memoizedFetchUser(2),
  memoizedFetchUser(1),
  memoizedFetchUser(2),
  memoizedFetchUser(2),
]).then((val) => {
  console.log(val);
});


***************************************************************************************************

function memoizeAsyncFunc(callbackFn) {
  let cache = new Map();

  return async function (...args) {
    const stringArgs = JSON.stringify(args);

    if (cache.has(stringArgs)) {
      const cached = cache.get(stringArgs);
      if (cached.success) {
        return cached.value;
      } else {
        throw cached.value;
      }
    }

    try {
      const result = await callbackFn(...args);
      cache.set(stringArgs, { success: true, value: result });
      return result;
    } catch (error) {
      cache.set(stringArgs, { success: false, value: error });
      throw error;
    }
  };
}

function givePromise(name) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(name);
    }, 1000);
  });
}

const memoize = memoizeAsyncFunc(givePromise);

memoize("saumyadip").then(console.log, console.log);
memoize("mandal").then(console.log, console.log);
memoize("saumyadip").then(console.log, console.log);

