// Polyfill for call

const data = { name: "Saumyadip" };

function printName() {
  console.log(`My name is ${this.name}`);
}

console.log("******** Normal call ********");
console.log(printName.call(data));

Function.prototype.myCall = function(context, ...args) {
  context = context || globalThis;  // default to global object if null/undefined
  const fnSymbol = Symbol();       // unique property key to avoid collisions
  context[fnSymbol] = this;        // assign the function to context temporarily

  const result = context[fnSymbol](...args);  // call function with args

  delete context[fnSymbol];        // clean up
  return result;                   // return function result
};

console.log("******** Polyfill call ********");
console.log(printName.myCall(data));

// Polyfill for apply

function printAllDetails(age) {
  console.log(`My name is ${this.name} and age is ${age}`);
}

Function.prototype.myApply = function(context, argsArray) {
  context = context || globalThis;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;

  let result;
  if (!argsArray) {
    result = context[fnSymbol]();
  } else {
    result = context[fnSymbol](...argsArray);
  }

  delete context[fnSymbol];
  return result;
};

console.log("******** Polyfill apply ********");
console.log(printAllDetails.myApply(data, [27]));

// Polyfill for bind

Function.prototype.myBind = function (context, ...bindArgs) {
  if (typeof this !== "function") {
    throw new TypeError("myBind can only be called on functions");
  }

  context = context || globalThis;
  const fn = this;

  return function (...callArgs) {
    const fnKey = Symbol(); // avoid name collision
    context[fnKey] = fn;

    const result = context[fnKey](...bindArgs, ...callArgs);

    delete context[fnKey]; // cleanup
    return result;
  };
};

console.log("******** Polyfill Bind ********");
const bindTest = printAllDetails.myBind(data);
console.log(bindTest(27));

// Polyfill for once

function once(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn.call(this, ...args);
    }
    return result;
  };
}


const Hello = once(() => {
  console.log("hello");
});

Hello();
Hello();
Hello();

/*
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

const alice = new Person('Alice', 30);
alice.greet(); // Outputs: Hello, my name is Alice and I am 30 years old.

*/

/*debounce polyfills*/
// Executes the function after a delay once no calls have been made for that time.
function debounce(fn, delay) {
  let timer;
  return function (...args) {
    const context = this;
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, delay);
  };
}

// throtlle 
// Executes the function at most once every specified interval.
function throttle(fn, delay) {
  let isThrottled = false;

  return function (...args) {
    const context = this;

    if (!isThrottled) {
      fn.apply(context, args);
      isThrottled = true;

      setTimeout(() => {
        isThrottled = false;
      }, delay);
    }
  };
}

