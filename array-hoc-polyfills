// Polyfill for map
const multiplier = {
  factor: 3,
  multiplyArray: function (arr) {
    return arr.map(function (num) {
      return num * this.factor;
    }, this);
  },
};

console.log(multiplier.multiplyArray([1, 2, 3]));

Array.prototype.myMap = function (callback, context) {
  let newArray = [];
  for (let index = 0; index < this.length; index += 1) {
    newArray[index] = callback.call(context, this[index], index, this);
  }
  return newArray;
};

const multiplier2 = {
  factor: 3,
  multiplyArray: function (arr) {
    return arr.myMap(function (num) {
      return num * this.factor;
    }, this);
  },
};

console.log(multiplier2.multiplyArray([1, 2, 3]));

// Polyfill for filter 
arr = [1, 2, 3, 4, 5, 6];

const filterElements = arr.filter((val) => val % 2);

console.log(filterElements);

Array.prototype.myFilter = function (callback, context) {
  let filteredArray = [];

  for (let index = 0; index < this.length; index += 1) {
    if (callback.call(context, this[index], index, this)) {
      filteredArray.push(this[index]);
    }
  }
  return filteredArray;
};

const newFilterElements = arr.myFilter((val) => val % 2);

console.log(newFilterElements);

// Polyfill for reduce
const array = [1, 2, 3, 4, 5, 6];

const red = array.reduce((acc, num) => {
  acc += num;
  return acc;
}, 37);

console.log(red);

Array.prototype.myReduce = function (callback, initialValue, context) {
  let acc;
  let startIndex = 0;

  if (arguments.length > 1) {
    // detects if initialValue is provided
    acc = initialValue;
  } else {
    acc = this[0];
    startIndex = 1;
  }

  for (let index = startIndex; index < this.length; index++) {
    acc = callback.call(context, acc, this[index], index, this);
  }

  return acc;
};

const newRed = array.myReduce((acc, num) => {
  acc += num;
  return acc;
}, 37);

console.log(newRed);

